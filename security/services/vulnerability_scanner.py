# security/services/vulnerability_scanner.py
import json
import logging
import subprocess
import requests
import tempfile
import os
from datetime import datetime, timedelta
from django.utils import timezone
from django.conf import settings
from django.core.files.storage import default_storage

from ..models import VulnerabilityAssessment, Vulnerability

logger = logging.getLogger('security.vulnerability_scanner')


class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanning service.
    Integrates multiple scanning tools and provides unified vulnerability management.
    """
    
    def __init__(self):
        self.scan_tools = {
            'owasp_zap': OWASPZAPScanner(),
            'dependency_check': DependencyScanner(),
            'network_scan': NetworkScanner(),
            'configuration_scan': ConfigurationScanner(),
            'code_scan': CodeScanner()
        }
        self.output_dir = getattr(settings, 'SECURITY_SCAN_OUTPUT_DIR', '/tmp/security_scans')
        os.makedirs(self.output_dir, exist_ok=True)
    
    def run_scan(self, assessment_id):
        """Run vulnerability scan based on assessment configuration."""
        try:
            assessment = VulnerabilityAssessment.objects.get(id=assessment_id)
            assessment.status = 'running'
            assessment.started_at = timezone.now()
            assessment.save(update_fields=['status', 'started_at'])
            
            logger.info(f"Starting vulnerability scan: {assessment.scan_type} for {assessment.target}")
            
            # Select appropriate scanner
            scanner = self._get_scanner_for_type(assessment.scan_type)
            if not scanner:
                raise ValueError(f"No scanner available for type: {assessment.scan_type}")
            
            # Run the scan
            scan_results = scanner.scan(assessment.target, assessment.scan_config)
            
            # Process results
            self._process_scan_results(assessment, scan_results)
            
            # Update assessment
            assessment.status = 'completed'
            assessment.completed_at = timezone.now()
            if assessment.started_at:
                duration = assessment.completed_at - assessment.started_at
                assessment.duration_seconds = int(duration.total_seconds())
            
            assessment.raw_results = scan_results
            assessment.save(update_fields=[
                'status', 'completed_at', 'duration_seconds', 'raw_results'
            ])
            
            logger.info(f"Vulnerability scan completed: {assessment.total_vulnerabilities} vulnerabilities found")
            
            # Generate report
            self._generate_scan_report(assessment)
            
            return assessment
            
        except Exception as e:
            logger.error(f"Error running vulnerability scan {assessment_id}: {str(e)}")
            
            try:
                assessment = VulnerabilityAssessment.objects.get(id=assessment_id)
                assessment.status = 'failed'
                assessment.completed_at = timezone.now()
                assessment.save(update_fields=['status', 'completed_at'])
            except:
                pass
            
            raise
    
    def _get_scanner_for_type(self, scan_type):
        """Get appropriate scanner for scan type."""
        scanner_mapping = {
            'web_app': self.scan_tools['owasp_zap'],
            'network': self.scan_tools['network_scan'],
            'dependency': self.scan_tools['dependency_check'],
            'configuration': self.scan_tools['configuration_scan'],
            'code': self.scan_tools['code_scan']
        }
        return scanner_mapping.get(scan_type)
    
    def _process_scan_results(self, assessment, scan_results):
        """Process scan results and create vulnerability records."""
        vulnerabilities_data = scan_results.get('vulnerabilities', [])
        
        severity_counts = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'info': 0
        }
        
        # Create vulnerability records
        for vuln_data in vulnerabilities_data:
            try:
                vulnerability = Vulnerability.objects.create(
                    assessment=assessment,
                    cve_id=vuln_data.get('cve_id', ''),
                    cwe_id=vuln_data.get('cwe_id', ''),
                    title=vuln_data.get('title', 'Unknown Vulnerability'),
                    description=vuln_data.get('description', ''),
                    severity=vuln_data.get('severity', 'medium').lower(),
                    cvss_score=vuln_data.get('cvss_score'),
                    cvss_vector=vuln_data.get('cvss_vector', ''),
                    affected_component=vuln_data.get('component', ''),
                    location=vuln_data.get('location', ''),
                    proof_of_concept=vuln_data.get('proof_of_concept', ''),
                    remediation_advice=vuln_data.get('remediation', ''),
                    references=vuln_data.get('references', [])
                )
                
                # Count by severity
                severity = vulnerability.severity
                if severity in severity_counts:
                    severity_counts[severity] += 1
                
            except Exception as e:
                logger.error(f"Error creating vulnerability record: {str(e)}")
        
        # Update assessment counts
        assessment.total_vulnerabilities = len(vulnerabilities_data)
        assessment.critical_count = severity_counts['critical']
        assessment.high_count = severity_counts['high']
        assessment.medium_count = severity_counts['medium']
        assessment.low_count = severity_counts['low']
        assessment.info_count = severity_counts['info']
        
        assessment.save(update_fields=[
            'total_vulnerabilities', 'critical_count', 'high_count',
            'medium_count', 'low_count', 'info_count'
        ])
    
    def _generate_scan_report(self, assessment):
        """Generate detailed scan report."""
        try:
            timestamp = timezone.now().strftime('%Y%m%d_%H%M%S')
            filename = f"vuln_scan_{assessment.scan_type}_{timestamp}.html"
            
            # Generate HTML report
            html_content = self._create_html_report(assessment)
            
            # Save report
            file_path = os.path.join(self.output_dir, filename)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            assessment.report_file_path = file_path
            assessment.save(update_fields=['report_file_path'])
            
        except Exception as e:
            logger.error(f"Error generating scan report: {str(e)}")
    
    def _create_html_report(self, assessment):
        """Create HTML vulnerability report."""
        vulnerabilities = Vulnerability.objects.filter(
            assessment=assessment
        ).order_by('-cvss_score', '-severity')
        
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Assessment Report - {assessment.target}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background: #2c3e50; color: white; padding: 20px; margin-bottom: 20px; }}
        .summary {{ background: #ecf0f1; padding: 15px; margin-bottom: 20px; border-radius: 5px; }}
        .vulnerability {{ border: 1px solid #bdc3c7; margin: 10px 0; padding: 15px; border-radius: 5px; }}
        .critical {{ border-left: 5px solid #e74c3c; }}
        .high {{ border-left: 5px solid #f39c12; }}
        .medium {{ border-left: 5px solid #f1c40f; }}
        .low {{ border-left: 5px solid #27ae60; }}
        .info {{ border-left: 5px solid #3498db; }}
        .severity {{ font-weight: bold; padding: 2px 8px; border-radius: 3px; color: white; }}
        .severity.critical {{ background-color: #e74c3c; }}
        .severity.high {{ background-color: #f39c12; }}
        .severity.medium {{ background-color: #f1c40f; color: black; }}
        .severity.low {{ background-color: #27ae60; }}
        .severity.info {{ background-color: #3498db; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Vulnerability Assessment Report</h1>
        <p>Target: {assessment.target}</p>
        <p>Scan Type: {assessment.get_scan_type_display()}</p>
        <p>Completed: {assessment.completed_at.strftime('%Y-%m-%d %H:%M:%S') if assessment.completed_at else 'N/A'}</p>
    </div>
    
    <div class="summary">
        <h2>Summary</h2>
        <p><strong>Total Vulnerabilities:</strong> {assessment.total_vulnerabilities}</p>
        <p><strong>Critical:</strong> {assessment.critical_count}</p>
        <p><strong>High:</strong> {assessment.high_count}</p>
        <p><strong>Medium:</strong> {assessment.medium_count}</p>
        <p><strong>Low:</strong> {assessment.low_count}</p>
        <p><strong>Informational:</strong> {assessment.info_count}</p>
    </div>
    
    <div class="vulnerabilities">
        <h2>Vulnerabilities</h2>
"""
        
        for vuln in vulnerabilities:
            html += f"""
        <div class="vulnerability {vuln.severity}">
            <h3>{vuln.title}</h3>
            <p><span class="severity {vuln.severity}">{vuln.get_severity_display()}</span>
            {f'CVSS: {vuln.cvss_score}' if vuln.cvss_score else ''}
            {f'CVE: {vuln.cve_id}' if vuln.cve_id else ''}</p>
            <p><strong>Component:</strong> {vuln.affected_component}</p>
            <p><strong>Location:</strong> {vuln.location}</p>
            <p><strong>Description:</strong> {vuln.description}</p>
            {f'<p><strong>Remediation:</strong> {vuln.remediation_advice}</p>' if vuln.remediation_advice else ''}
        </div>
"""
        
        html += """
    </div>
</body>
</html>
"""
        return html


class OWASPZAPScanner:
    """OWASP ZAP web application scanner integration."""
    
    def __init__(self):
        self.zap_api_key = getattr(settings, 'ZAP_API_KEY', '')
        self.zap_proxy_url = getattr(settings, 'ZAP_PROXY_URL', 'http://localhost:8080')
    
    def scan(self, target_url, config=None):
        """Run OWASP ZAP scan against target URL."""
        try:
            logger.info(f"Starting OWASP ZAP scan for {target_url}")
            
            # This would integrate with actual OWASP ZAP API
            # For now, returning simulated results
            
            vulnerabilities = self._simulate_web_scan_results(target_url)
            
            return {
                'scanner': 'OWASP ZAP',
                'target': target_url,
                'scan_time': timezone.now().isoformat(),
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            logger.error(f"OWASP ZAP scan failed: {str(e)}")
            raise
    
    def _simulate_web_scan_results(self, target_url):
        """Simulate web application scan results."""
        # In production, this would parse actual ZAP results
        return [
            {
                'title': 'SQL Injection',
                'description': 'Potential SQL injection vulnerability detected in login form',
                'severity': 'high',
                'cvss_score': 8.5,
                'cwe_id': 'CWE-89',
                'component': 'Login Form',
                'location': f'{target_url}/login',
                'proof_of_concept': "Parameter 'username' appears vulnerable to SQL injection",
                'remediation': 'Use parameterized queries and input validation'
            },
            {
                'title': 'Cross-Site Scripting (XSS)',
                'description': 'Reflected XSS vulnerability in search parameter',
                'severity': 'medium',
                'cvss_score': 6.1,
                'cwe_id': 'CWE-79',
                'component': 'Search Function',
                'location': f'{target_url}/search',
                'proof_of_concept': "Parameter 'q' reflects user input without encoding",
                'remediation': 'Implement proper input validation and output encoding'
            }
        ]


class DependencyScanner:
    """Dependency vulnerability scanner."""
    
    def scan(self, target_path, config=None):
        """Scan dependencies for known vulnerabilities."""
        try:
            logger.info(f"Starting dependency scan for {target_path}")
            
            # Use safety to scan Python dependencies
            vulnerabilities = self._scan_python_dependencies()
            
            # Use npm audit for Node.js dependencies if applicable
            vulnerabilities.extend(self._scan_npm_dependencies())
            
            return {
                'scanner': 'Dependency Scanner',
                'target': target_path,
                'scan_time': timezone.now().isoformat(),
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            logger.error(f"Dependency scan failed: {str(e)}")
            raise
    
    def _scan_python_dependencies(self):
        """Scan Python dependencies using safety."""
        vulnerabilities = []
        
        try:
            # Run safety check
            result = subprocess.run(
                ['safety', 'check', '--json'],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                # Parse safety results
                safety_data = json.loads(result.stdout)
                
                for vuln in safety_data:
                    vulnerabilities.append({
                        'title': f"Vulnerable dependency: {vuln.get('package_name')}",
                        'description': vuln.get('advisory', ''),
                        'severity': self._map_safety_severity(vuln.get('severity')),
                        'cve_id': vuln.get('cve', ''),
                        'component': vuln.get('package_name', ''),
                        'location': f"requirements.txt:{vuln.get('package_name')}",
                        'remediation': f"Update to version {vuln.get('safe_version', 'latest')}"
                    })
            
        except subprocess.TimeoutExpired:
            logger.warning("Safety scan timed out")
        except FileNotFoundError:
            logger.warning("Safety not installed, skipping Python dependency scan")
        except Exception as e:
            logger.error(f"Error running safety scan: {str(e)}")
        
        return vulnerabilities
    
    def _scan_npm_dependencies(self):
        """Scan Node.js dependencies using npm audit."""
        vulnerabilities = []
        
        try:
            # Check if package.json exists
            if os.path.exists('package.json'):
                result = subprocess.run(
                    ['npm', 'audit', '--json'],
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                
                if result.stdout:
                    audit_data = json.loads(result.stdout)
                    
                    # Parse npm audit results
                    for vuln_id, vuln_data in audit_data.get('vulnerabilities', {}).items():
                        vulnerabilities.append({
                            'title': f"NPM vulnerability: {vuln_data.get('module_name')}",
                            'description': vuln_data.get('title', ''),
                            'severity': vuln_data.get('severity', 'medium'),
                            'cve_id': vuln_data.get('cves', [''])[0],
                            'component': vuln_data.get('module_name', ''),
                            'location': f"package.json:{vuln_data.get('module_name')}",
                            'remediation': vuln_data.get('recommendation', '')
                        })
            
        except subprocess.TimeoutExpired:
            logger.warning("NPM audit timed out")
        except FileNotFoundError:
            logger.warning("NPM not found, skipping Node.js dependency scan")
        except Exception as e:
            logger.error(f"Error running npm audit: {str(e)}")
        
        return vulnerabilities
    
    def _map_safety_severity(self, safety_severity):
        """Map safety severity to standard severity levels."""
        mapping = {
            'high': 'high',
            'medium': 'medium',
            'low': 'low'
        }
        return mapping.get(safety_severity, 'medium')


class NetworkScanner:
    """Network vulnerability scanner."""
    
    def scan(self, target_host, config=None):
        """Scan network target for vulnerabilities."""
        try:
            logger.info(f"Starting network scan for {target_host}")
            
            # Simulate network scan results
            vulnerabilities = self._simulate_network_scan(target_host)
            
            return {
                'scanner': 'Network Scanner',
                'target': target_host,
                'scan_time': timezone.now().isoformat(),
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            logger.error(f"Network scan failed: {str(e)}")
            raise
    
    def _simulate_network_scan(self, target_host):
        """Simulate network scan results."""
        return [
            {
                'title': 'Open SSH Port with Weak Configuration',
                'description': 'SSH service allows password authentication',
                'severity': 'medium',
                'component': 'SSH Service',
                'location': f'{target_host}:22',
                'remediation': 'Disable password authentication and use key-based authentication'
            },
            {
                'title': 'Unencrypted HTTP Service',
                'description': 'Web service running on unencrypted HTTP',
                'severity': 'low',
                'component': 'Web Server',
                'location': f'{target_host}:80',
                'remediation': 'Implement HTTPS and redirect HTTP traffic'
            }
        ]


class ConfigurationScanner:
    """Security configuration scanner."""
    
    def scan(self, target_system, config=None):
        """Scan system configuration for security issues."""
        try:
            logger.info(f"Starting configuration scan for {target_system}")
            
            vulnerabilities = []
            
            # Check Django security settings
            vulnerabilities.extend(self._check_django_security())
            
            # Check system configuration
            vulnerabilities.extend(self._check_system_configuration())
            
            return {
                'scanner': 'Configuration Scanner',
                'target': target_system,
                'scan_time': timezone.now().isoformat(),
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            logger.error(f"Configuration scan failed: {str(e)}")
            raise
    
    def _check_django_security(self):
        """Check Django security configuration."""
        vulnerabilities = []
        
        # Check DEBUG setting
        if getattr(settings, 'DEBUG', False):
            vulnerabilities.append({
                'title': 'DEBUG Mode Enabled',
                'description': 'Django DEBUG mode is enabled in production',
                'severity': 'high',
                'component': 'Django Configuration',
                'location': 'settings.py',
                'remediation': 'Set DEBUG = False in production'
            })
        
        # Check SECRET_KEY
        secret_key = getattr(settings, 'SECRET_KEY', '')
        if not secret_key or len(secret_key) < 50:
            vulnerabilities.append({
                'title': 'Weak Secret Key',
                'description': 'Django SECRET_KEY is weak or missing',
                'severity': 'critical',
                'component': 'Django Configuration',
                'location': 'settings.py',
                'remediation': 'Generate a strong, random SECRET_KEY'
            })
        
        # Check HTTPS settings
        if not getattr(settings, 'SECURE_SSL_REDIRECT', False):
            vulnerabilities.append({
                'title': 'HTTPS Not Enforced',
                'description': 'SECURE_SSL_REDIRECT is not enabled',
                'severity': 'medium',
                'component': 'Django Security',
                'location': 'settings.py',
                'remediation': 'Enable SECURE_SSL_REDIRECT = True'
            })
        
        return vulnerabilities
    
    def _check_system_configuration(self):
        """Check system-level security configuration."""
        vulnerabilities = []
        
        # Check file permissions
        try:
            # Check if sensitive files have proper permissions
            sensitive_files = ['/etc/passwd', '/etc/shadow']
            for file_path in sensitive_files:
                if os.path.exists(file_path):
                    stat_info = os.stat(file_path)
                    if stat_info.st_mode & 0o077:  # World or group readable
                        vulnerabilities.append({
                            'title': f'Insecure File Permissions: {file_path}',
                            'description': f'Sensitive file {file_path} has overly permissive permissions',
                            'severity': 'medium',
                            'component': 'File System',
                            'location': file_path,
                            'remediation': f'Set proper permissions: chmod 600 {file_path}'
                        })
        except Exception as e:
            logger.error(f"Error checking file permissions: {str(e)}")
        
        return vulnerabilities


class CodeScanner:
    """Static code analysis scanner."""
    
    def scan(self, code_path, config=None):
        """Scan code for security vulnerabilities."""
        try:
            logger.info(f"Starting code scan for {code_path}")
            
            vulnerabilities = []
            
            # Run bandit for Python security issues
            vulnerabilities.extend(self._run_bandit_scan(code_path))
            
            # Custom security pattern checks
            vulnerabilities.extend(self._check_custom_patterns(code_path))
            
            return {
                'scanner': 'Code Scanner',
                'target': code_path,
                'scan_time': timezone.now().isoformat(),
                'vulnerabilities': vulnerabilities
            }
            
        except Exception as e:
            logger.error(f"Code scan failed: {str(e)}")
            raise
    
    def _run_bandit_scan(self, code_path):
        """Run Bandit security scanner on Python code."""
        vulnerabilities = []
        
        try:
            result = subprocess.run(
                ['bandit', '-r', code_path, '-f', 'json'],
                capture_output=True,
                text=True,
                timeout=600
            )
            
            if result.stdout:
                bandit_data = json.loads(result.stdout)
                
                for issue in bandit_data.get('results', []):
                    severity_map = {
                        'HIGH': 'high',
                        'MEDIUM': 'medium',
                        'LOW': 'low'
                    }
                    
                    vulnerabilities.append({
                        'title': issue.get('test_name', 'Security Issue'),
                        'description': issue.get('issue_text', ''),
                        'severity': severity_map.get(issue.get('issue_severity'), 'medium'),
                        'cwe_id': f"CWE-{issue.get('test_id', '')}",
                        'component': 'Source Code',
                        'location': f"{issue.get('filename')}:{issue.get('line_number')}",
                        'proof_of_concept': issue.get('code', ''),
                        'remediation': 'Review and fix the security issue in the code'
                    })
        
        except subprocess.TimeoutExpired:
            logger.warning("Bandit scan timed out")
        except FileNotFoundError:
            logger.warning("Bandit not installed, skipping code scan")
        except Exception as e:
            logger.error(f"Error running bandit scan: {str(e)}")
        
        return vulnerabilities
    
    def _check_custom_patterns(self, code_path):
        """Check for custom security patterns."""
        vulnerabilities = []
        
        # Define security anti-patterns
        patterns = [
            {
                'pattern': r'password\s*=\s*["\'][^"\']+["\']',
                'title': 'Hardcoded Password',
                'severity': 'high',
                'description': 'Hardcoded password found in source code'
            },
            {
                'pattern': r'api_key\s*=\s*["\'][^"\']+["\']',
                'title': 'Hardcoded API Key',
                'severity': 'high',
                'description': 'Hardcoded API key found in source code'
            }
        ]
        
        try:
            import re
            
            for root, dirs, files in os.walk(code_path):
                for file in files:
                    if file.endswith('.py'):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                content = f.read()
                                
                                for pattern_info in patterns:
                                    matches = re.finditer(pattern_info['pattern'], content, re.IGNORECASE)
                                    for match in matches:
                                        line_num = content[:match.start()].count('\n') + 1
                                        
                                        vulnerabilities.append({
                                            'title': pattern_info['title'],
                                            'description': pattern_info['description'],
                                            'severity': pattern_info['severity'],
                                            'component': 'Source Code',
                                            'location': f"{file_path}:{line_num}",
                                            'proof_of_concept': match.group(),
                                            'remediation': 'Move sensitive data to environment variables or secure configuration'
                                        })
                        except Exception as e:
                            logger.error(f"Error scanning file {file_path}: {str(e)}")
        
        except Exception as e:
            logger.error(f"Error in custom pattern check: {str(e)}")
        
        return vulnerabilities
